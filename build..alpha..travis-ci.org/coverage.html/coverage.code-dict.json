{"/home/travis/build/npmtest/node-npmtest-firmata/test.js":"/* istanbul instrument in package npmtest_firmata */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-firmata/lib.npmtest_firmata.js":"/* istanbul instrument in package npmtest_firmata */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_firmata = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_firmata = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-firmata/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-firmata && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_firmata */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_firmata\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_firmata.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_firmata.rollup.js'] =\n            local.assetsDict['/assets.npmtest_firmata.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_firmata.__dirname + '/lib.npmtest_firmata.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-firmata/node_modules/firmata/lib/firmata.js":"// Global Environment Dependencies\n/* istanbul ignore if */\n/* jshint -W079 */\nif (!Object.assign || !Map) {\n  require(\"es6-shim\");\n}\n\n// Built-in Dependencies\nvar Emitter = require(\"events\").EventEmitter;\n\n// Internal Dependencies\nvar Encoder7Bit = require(\"./encoder7bit\");\nvar OneWireUtils = require(\"./onewireutils\");\nvar com = require(\"./com\");\n\n// Program specifics\nvar i2cActive = new Map();\n\n/**\n * constants\n */\n\nvar ANALOG_MAPPING_QUERY = 0x69;\nvar ANALOG_MAPPING_RESPONSE = 0x6A;\nvar ANALOG_MESSAGE = 0xE0;\nvar CAPABILITY_QUERY = 0x6B;\nvar CAPABILITY_RESPONSE = 0x6C;\nvar DIGITAL_MESSAGE = 0x90;\nvar END_SYSEX = 0xF7;\nvar EXTENDED_ANALOG = 0x6F;\nvar I2C_CONFIG = 0x78;\nvar I2C_REPLY = 0x77;\nvar I2C_REQUEST = 0x76;\nvar I2C_READ_MASK = 0x18;   // 0b00011000\nvar I2C_END_TX_MASK = 0x40; // 0b01000000\nvar ONEWIRE_CONFIG_REQUEST = 0x41;\nvar ONEWIRE_DATA = 0x73;\nvar ONEWIRE_DELAY_REQUEST_BIT = 0x10;\nvar ONEWIRE_READ_REPLY = 0x43;\nvar ONEWIRE_READ_REQUEST_BIT = 0x08;\nvar ONEWIRE_RESET_REQUEST_BIT = 0x01;\nvar ONEWIRE_SEARCH_ALARMS_REPLY = 0x45;\nvar ONEWIRE_SEARCH_ALARMS_REQUEST = 0x44;\nvar ONEWIRE_SEARCH_REPLY = 0x42;\nvar ONEWIRE_SEARCH_REQUEST = 0x40;\nvar ONEWIRE_WITHDATA_REQUEST_BITS = 0x3C;\nvar ONEWIRE_WRITE_REQUEST_BIT = 0x20;\nvar PIN_MODE = 0xF4;\nvar PIN_STATE_QUERY = 0x6D;\nvar PIN_STATE_RESPONSE = 0x6E;\nvar PING_READ = 0x75;\nvar PULSE_IN = 0x74;\nvar PULSE_OUT = 0x73;\nvar QUERY_FIRMWARE = 0x79;\nvar REPORT_ANALOG = 0xC0;\nvar REPORT_DIGITAL = 0xD0;\nvar REPORT_VERSION = 0xF9;\nvar SAMPLING_INTERVAL = 0x7A;\nvar SERVO_CONFIG = 0x70;\nvar SERIAL_MESSAGE = 0x60;\nvar SERIAL_CONFIG = 0x10;\nvar SERIAL_WRITE = 0x20;\nvar SERIAL_READ = 0x30;\nvar SERIAL_REPLY = 0x40;\nvar SERIAL_CLOSE = 0x50;\nvar SERIAL_FLUSH = 0x60;\nvar SERIAL_LISTEN = 0x70;\nvar START_SYSEX = 0xF0;\nvar STEPPER = 0x72;\nvar STRING_DATA = 0x71;\nvar SYSTEM_RESET = 0xFF;\n\nvar MAX_PIN_COUNT = 128;\n\n/**\n * MIDI_RESPONSE contains functions to be called when we receive a MIDI message from the arduino.\n * used as a switch object as seen here http://james.padolsey.com/javascript/how-to-avoid-switch-case-syndrome/\n * @private\n */\n\nvar MIDI_RESPONSE = {};\n\n/**\n * Handles a REPORT_VERSION response and emits the reportversion event.\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nMIDI_RESPONSE[REPORT_VERSION] = function(board) {\n  board.version.major = board.currentBuffer[1];\n  board.version.minor = board.currentBuffer[2];\n  board.emit(\"reportversion\");\n};\n\n/**\n * Handles a ANALOG_MESSAGE response and emits \"analog-read\" and \"analog-read-\"+n events where n is the pin number.\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nMIDI_RESPONSE[ANALOG_MESSAGE] = function(board) {\n  var pin = board.currentBuffer[0] & 0x0F;\n  var value = board.currentBuffer[1] | (board.currentBuffer[2] << 7);\n\n  /* istanbul ignore else */\n  if (board.pins[board.analogPins[pin]]) {\n    board.pins[board.analogPins[pin]].value = value;\n  }\n\n  board.emit(\"analog-read-\" + pin, value);\n  board.emit(\"analog-read\", {\n    pin: pin,\n    value: value,\n  });\n};\n\n/**\n * Handles a DIGITAL_MESSAGE response and emits:\n * \"digital-read\"\n * \"digital-read-\"+n\n *\n * Where n is the pin number.\n *\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nMIDI_RESPONSE[DIGITAL_MESSAGE] = function(board) {\n  var port = (board.currentBuffer[0] & 0x0F);\n  var portValue = board.currentBuffer[1] | (board.currentBuffer[2] << 7);\n\n  for (var i = 0; i < 8; i++) {\n    var pinNumber = 8 * port + i;\n    var pin = board.pins[pinNumber];\n    var bit = 1 << i;\n\n    if (pin && (pin.mode === board.MODES.INPUT || pin.mode === board.MODES.PULLUP)) {\n      pin.value = (portValue >> (i & 0x07)) & 0x01;\n\n      if (pin.value) {\n        board.ports[port] |= bit;\n      } else {\n        board.ports[port] &= ~bit;\n      }\n\n      board.emit(\"digital-read-\" + pinNumber, pin.value);\n      board.emit(\"digital-read\", {\n        pin: pinNumber,\n        value: pin.value,\n      });\n    }\n  }\n};\n\n/**\n * SYSEX_RESPONSE contains functions to be called when we receive a SYSEX message from the arduino.\n * used as a switch object as seen here http://james.padolsey.com/javascript/how-to-avoid-switch-case-syndrome/\n * @private\n */\n\nvar SYSEX_RESPONSE = {};\n\n/**\n * Handles a QUERY_FIRMWARE response and emits the \"queryfirmware\" event\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nSYSEX_RESPONSE[QUERY_FIRMWARE] = function(board) {\n  var length = board.currentBuffer.length - 2;\n  var buffer = new Buffer(Math.round((length - 4) / 2));\n  var byte = 0;\n  var offset = 0;\n\n  for (var i = 4; i < length; i += 2) {\n    byte = ((board.currentBuffer[i] & 0x7F) | ((board.currentBuffer[i + 1] & 0x7F) << 7)) & 0xFF;\n    buffer.writeUInt8(byte, offset++);\n  }\n\n  board.firmware = {\n    name: buffer.toString(),\n    version: {\n      major: board.currentBuffer[2],\n      minor: board.currentBuffer[3],\n    },\n  };\n\n  board.emit(\"queryfirmware\");\n};\n\n/**\n * Handles a CAPABILITY_RESPONSE response and emits the \"capability-query\" event\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nSYSEX_RESPONSE[CAPABILITY_RESPONSE] = function(board) {\n  var mode, resolution;\n  var modes = Object.keys(board.MODES).map(function(key) {\n    return board.MODES[key];\n  });\n  var capability = 0;\n\n  function supportedModes(capability) {\n    return modes.reduce(function(accum, mode, index) {\n      if (capability & (1 << mode)) {\n        accum.push(mode);\n      }\n      return accum;\n    }, []);\n  }\n\n  // Only create pins if none have been previously created on the instance.\n  if (!board.pins.length) {\n    for (var i = 2, n = 0; i < board.currentBuffer.length - 1; i++) {\n      if (board.currentBuffer[i] === 127) {\n        board.pins.push({\n          supportedModes: supportedModes(capability),\n          mode: undefined,\n          value: 0,\n          report: 1,\n        });\n        capability = 0;\n        n = 0;\n        continue;\n      }\n      if (n === 0) {\n        mode = board.currentBuffer[i];\n        resolution = (1 << board.currentBuffer[i + 1]) - 1;\n        capability |= (1 << mode);\n\n        // ADC Resolution of Analog Inputs\n        if (mode === board.MODES.ANALOG && board.RESOLUTION.ADC === null) {\n          board.RESOLUTION.ADC = resolution;\n        }\n\n        // PWM Resolution of PWM Outputs\n        if (mode === board.MODES.PWM && board.RESOLUTION.PWM === null) {\n          board.RESOLUTION.PWM = resolution;\n        }\n\n        // DAC Resolution of DAC Outputs\n        // if (mode === board.MODES.DAC && board.RESOLUTION.DAC === null) {\n        //   board.RESOLUTION.DAC = resolution;\n        // }\n      }\n      n ^= 1;\n    }\n  }\n\n  board.emit(\"capability-query\");\n};\n\n/**\n * Handles a PIN_STATE response and emits the 'pin-state-'+n event where n is the pin number.\n *\n * Note about pin state: For output modes, the state is any value that has been\n * previously written to the pin. For input modes, the state is the status of\n * the pullup resistor.\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nSYSEX_RESPONSE[PIN_STATE_RESPONSE] = function (board) {\n  var pin = board.currentBuffer[2];\n  board.pins[pin].mode = board.currentBuffer[3];\n  board.pins[pin].state = board.currentBuffer[4];\n  if (board.currentBuffer.length > 6) {\n    board.pins[pin].state |= (board.currentBuffer[5] << 7);\n  }\n  if (board.currentBuffer.length > 7) {\n    board.pins[pin].state |= (board.currentBuffer[6] << 14);\n  }\n  board.emit(\"pin-state-\" + pin);\n};\n\n/**\n * Handles a ANALOG_MAPPING_RESPONSE response and emits the \"analog-mapping-query\" event.\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nSYSEX_RESPONSE[ANALOG_MAPPING_RESPONSE] = function(board) {\n  var pin = 0;\n  var currentValue;\n  for (var i = 2; i < board.currentBuffer.length - 1; i++) {\n    currentValue = board.currentBuffer[i];\n    board.pins[pin].analogChannel = currentValue;\n    if (currentValue !== 127) {\n      board.analogPins.push(pin);\n    }\n    pin++;\n  }\n  board.emit(\"analog-mapping-query\");\n};\n\n/**\n * Handles a I2C_REPLY response and emits the \"I2C-reply-\"+n event where n is the slave address of the I2C device.\n * The event is passed the buffer of data sent from the I2C Device\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nSYSEX_RESPONSE[I2C_REPLY] = function(board) {\n  var reply = [];\n  var address = (board.currentBuffer[2] & 0x7F) | ((board.currentBuffer[3] & 0x7F) << 7);\n  var register = (board.currentBuffer[4] & 0x7F) | ((board.currentBuffer[5] & 0x7F) << 7);\n\n  for (var i = 6, length = board.currentBuffer.length - 1; i < length; i += 2) {\n    reply.push(board.currentBuffer[i] | (board.currentBuffer[i + 1] << 7));\n  }\n\n  board.emit(\"I2C-reply-\" + address + \"-\" + register, reply);\n};\n\nSYSEX_RESPONSE[ONEWIRE_DATA] = function(board) {\n  var subCommand = board.currentBuffer[2];\n\n  if (!SYSEX_RESPONSE[subCommand]) {\n    return;\n  }\n\n  SYSEX_RESPONSE[subCommand](board);\n};\n\nSYSEX_RESPONSE[ONEWIRE_SEARCH_REPLY] = function(board) {\n  var pin = board.currentBuffer[3];\n  var replyBuffer = board.currentBuffer.slice(4, board.currentBuffer.length - 1);\n\n  board.emit(\"1-wire-search-reply-\" + pin, OneWireUtils.readDevices(replyBuffer));\n};\n\nSYSEX_RESPONSE[ONEWIRE_SEARCH_ALARMS_REPLY] = function(board) {\n  var pin = board.currentBuffer[3];\n  var replyBuffer = board.currentBuffer.slice(4, board.currentBuffer.length - 1);\n\n  board.emit(\"1-wire-search-alarms-reply-\" + pin, OneWireUtils.readDevices(replyBuffer));\n};\n\nSYSEX_RESPONSE[ONEWIRE_READ_REPLY] = function(board) {\n  var encoded = board.currentBuffer.slice(4, board.currentBuffer.length - 1);\n  var decoded = Encoder7Bit.from7BitArray(encoded);\n  var correlationId = (decoded[1] << 8) | decoded[0];\n\n  board.emit(\"1-wire-read-reply-\" + correlationId, decoded.slice(2));\n};\n\n/**\n * Handles a STRING_DATA response and logs the string to the console.\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nSYSEX_RESPONSE[STRING_DATA] = function(board) {\n  var string = new Buffer(board.currentBuffer.slice(2, -1)).toString(\"utf8\").replace(/\\0/g, \"\");\n  board.emit(\"string\", string);\n};\n\n/**\n * Response from pingRead\n */\n\nSYSEX_RESPONSE[PING_READ] = function(board) {\n  var pin = (board.currentBuffer[2] & 0x7F) | ((board.currentBuffer[3] & 0x7F) << 7);\n  var durationBuffer = [\n    (board.currentBuffer[4] & 0x7F) | ((board.currentBuffer[5] & 0x7F) << 7),\n    (board.currentBuffer[6] & 0x7F) | ((board.currentBuffer[7] & 0x7F) << 7),\n    (board.currentBuffer[8] & 0x7F) | ((board.currentBuffer[9] & 0x7F) << 7),\n    (board.currentBuffer[10] & 0x7F) | ((board.currentBuffer[11] & 0x7F) << 7),\n  ];\n  var duration = ((durationBuffer[0] << 24) +\n    (durationBuffer[1] << 16) +\n    (durationBuffer[2] << 8) +\n    (durationBuffer[3]));\n  board.emit(\"ping-read-\" + pin, duration);\n};\n\n/**\n * Handles the message from a stepper completing move\n * @param {Board} board\n */\n\nSYSEX_RESPONSE[STEPPER] = function(board) {\n  var deviceNum = board.currentBuffer[2];\n  board.emit(\"stepper-done-\" + deviceNum, true);\n};\n\n/**\n * Handles a SERIAL_REPLY response and emits the \"serial-data-\"+n event where n is the id of the\n * serial port.\n * The event is passed the buffer of data sent from the serial device\n * @private\n * @param {Board} board the current arduino board we are working with.\n */\n\nSYSEX_RESPONSE[SERIAL_MESSAGE] = function(board) {\n  var command = board.currentBuffer[2] & 0xF0;\n  var portId = board.currentBuffer[2] & 0x0F;\n  var reply = [];\n\n  /* istanbul ignore else */\n  if (command === SERIAL_REPLY) {\n    for (var i = 3, len = board.currentBuffer.length; i < len - 1; i += 2) {\n      reply.push((board.currentBuffer[i + 1] << 7) | board.currentBuffer[i]);\n    }\n    board.emit(\"serial-data-\" + portId, reply);\n  }\n};\n\n/**\n * @class The Board object represents an arduino board.\n * @augments EventEmitter\n * @param {String} port This is the serial port the arduino is connected to.\n * @param {function} function A function to be called when the arduino is ready to communicate.\n * @property MODES All the modes available for pins on this arduino board.\n * @property I2C_MODES All the I2C modes available.\n * @property SERIAL_MODES All the Serial modes available.\n * @property SERIAL_PORT_ID ID values to pass as the portId parameter when calling serialConfig.\n * @property HIGH A constant to set a pins value to HIGH when the pin is set to an output.\n * @property LOW A constant to set a pins value to LOW when the pin is set to an output.\n * @property pins An array of pin object literals.\n * @property analogPins An array of analog pins and their corresponding indexes in the pins array.\n * @property version An object indicating the major and minor version of the firmware currently running.\n * @property firmware An object indicateon the name, major and minor version of the firmware currently running.\n * @property currentBuffer An array holding the current bytes received from the arduino.\n * @property {SerialPort} sp The serial port object used to communicate with the arduino.\n */\n\nfunction Board(port, options, callback) {\n  if (typeof options === \"function\" || typeof options === \"undefined\") {\n    callback = options;\n    options = {};\n  }\n\n  if (!(this instanceof Board)) {\n    return new Board(port, options, callback);\n  }\n\n  Emitter.call(this);\n\n  var board = this;\n  var defaults = {\n    reportVersionTimeout: 5000,\n    samplingInterval: 19,\n    serialport: {\n      baudRate: 57600,\n      bufferSize: 256,\n    },\n  };\n\n  var settings = Object.assign({}, defaults, options);\n\n  this.isReady = false;\n\n  this.MODES = {\n    INPUT: 0x00,\n    OUTPUT: 0x01,\n    ANALOG: 0x02,\n    PWM: 0x03,\n    SERVO: 0x04,\n    SHIFT: 0x05,\n    I2C: 0x06,\n    ONEWIRE: 0x07,\n    STEPPER: 0x08,\n    SERIAL: 0x0A,\n    PULLUP: 0x0B,\n    IGNORE: 0x7F,\n    PING_READ: 0x75,\n    UNKOWN: 0x10,\n  };\n\n  this.I2C_MODES = {\n    WRITE: 0,\n    READ: 1,\n    CONTINUOUS_READ: 2,\n    STOP_READING: 3,\n  };\n\n  this.STEPPER = {\n    TYPE: {\n      DRIVER: 1,\n      TWO_WIRE: 2,\n      FOUR_WIRE: 4,\n    },\n    RUNSTATE: {\n      STOP: 0,\n      ACCEL: 1,\n      DECEL: 2,\n      RUN: 3,\n    },\n    DIRECTION: {\n      CCW: 0,\n      CW: 1,\n    },\n  };\n\n  this.SERIAL_MODES = {\n    CONTINUOUS_READ: 0x00,\n    STOP_READING: 0x01,\n  };\n\n  // ids for hardware and software serial ports on the board\n  this.SERIAL_PORT_IDs = {\n    HW_SERIAL0: 0x00,\n    HW_SERIAL1: 0x01,\n    HW_SERIAL2: 0x02,\n    HW_SERIAL3: 0x03,\n    SW_SERIAL0: 0x08,\n    SW_SERIAL1: 0x09,\n    SW_SERIAL2: 0x10,\n    SW_SERIAL3: 0x11,\n\n    // Default can be used by depender libraries to key on a\n    // single property name when negotiating ports.\n    //\n    // Firmata elects SW_SERIAL0: 0x08 as its DEFAULT\n    DEFAULT: 0x08,\n  };\n\n  // map to the pin resolution value in the capability query response\n  this.SERIAL_PIN_TYPES = {\n    RES_RX0: 0x00,\n    RES_TX0: 0x01,\n    RES_RX1: 0x02,\n    RES_TX1: 0x03,\n    RES_RX2: 0x04,\n    RES_TX2: 0x05,\n    RES_RX3: 0x06,\n    RES_TX3: 0x07,\n  };\n\n  this.RESOLUTION = {\n    ADC: null,\n    DAC: null,\n    PWM: null,\n  };\n\n  this.HIGH = 1;\n  this.LOW = 0;\n  this.pins = [];\n  this.ports = Array(16).fill(0);\n  this.analogPins = [];\n  this.version = {};\n  this.firmware = {};\n  this.currentBuffer = [];\n  this.versionReceived = false;\n  this.name = \"Firmata\";\n  this.settings = settings;\n  this.pending = 0;\n\n  if (typeof port === \"object\") {\n    this.transport = port;\n  } else {\n    this.transport = new com.SerialPort(port, settings.serialport);\n  }\n\n  // For backward compat\n  this.sp = this.transport;\n\n  this.transport.on(\"close\", function() {\n    this.emit(\"close\");\n  }.bind(this));\n\n  this.transport.on(\"disconnect\", function() {\n    this.emit(\"disconnect\");\n  }.bind(this));\n\n  this.transport.on(\"open\", function() {\n    this.emit(\"open\");\n    // Legacy\n    this.emit(\"connect\");\n  }.bind(this));\n\n  this.transport.on(\"error\", function(error) {\n    if (!this.isReady && typeof callback === \"function\") {\n      callback(error);\n    } else {\n      this.emit(\"error\", error);\n    }\n  }.bind(this));\n\n  this.transport.on(\"data\", function(data) {\n    var byte, currByte, response, first, last, handler;\n\n    for (var i = 0; i < data.length; i++) {\n      byte = data[i];\n      // we dont want to push 0 as the first byte on our buffer\n      if (this.currentBuffer.length === 0 && byte === 0) {\n        continue;\n      } else {\n        this.currentBuffer.push(byte);\n\n        first = this.currentBuffer[0];\n        last = this.currentBuffer[this.currentBuffer.length - 1];\n\n        // [START_SYSEX, ... END_SYSEX]\n        if (first === START_SYSEX && last === END_SYSEX) {\n\n          handler = SYSEX_RESPONSE[this.currentBuffer[1]];\n\n          // Ensure a valid SYSEX_RESPONSE handler exists\n          // Only process these AFTER the REPORT_VERSION\n          // message has been received and processed.\n          if (handler && this.versionReceived) {\n            handler(this);\n          }\n\n          // It is possible for the board to have\n          // existing activity from a previous run\n          // that will leave any of the following\n          // active:\n          //\n          //    - ANALOG_MESSAGE\n          //    - SERIAL_READ\n          //    - I2C_REQUEST, CONTINUOUS_READ\n          //\n          // This means that we will receive these\n          // messages on transport \"open\", before any\n          // handshake can occur. We MUST assert\n          // that we will only process this buffer\n          // AFTER the REPORT_VERSION message has\n          // been received. Not doing so will result\n          // in the appearance of the program \"hanging\".\n          //\n          // Since we cannot do anything with this data\n          // until _after_ REPORT_VERSION, discard it.\n          //\n          this.currentBuffer.length = 0;\n\n        } else if (first === START_SYSEX && (this.currentBuffer.length > 0)) {\n          // we have a new command after an incomplete sysex command\n          currByte = data[i];\n          if (currByte > 0x7F) {\n            this.currentBuffer.length = 0;\n            this.currentBuffer.push(currByte);\n          }\n        } else {\n          /* istanbul ignore else */\n          if (first !== START_SYSEX) {\n            // Check if data gets out of sync: first byte in buffer\n            // must be a valid response if not START_SYSEX\n            // Identify response on first byte\n            response = first < START_SYSEX ? (first & START_SYSEX) : first;\n\n            // Check if the first byte is possibly\n            // a valid MIDI_RESPONSE (handler)\n            /* istanbul ignore else */\n            if (response !== REPORT_VERSION &&\n                response !== ANALOG_MESSAGE &&\n                response !== DIGITAL_MESSAGE) {\n              // If not valid, then we received garbage and can discard\n              // whatever bytes have been been queued.\n              this.currentBuffer.length = 0;\n            }\n          }\n        }\n\n        // There are 3 bytes in the buffer and the first is not START_SYSEX:\n        // Might have a MIDI Command\n        if (this.currentBuffer.length === 3 && first !== START_SYSEX) {\n          // response bytes under 0xF0 we have a multi byte operation\n          response = first < START_SYSEX ? (first & START_SYSEX) : first;\n\n          /* istanbul ignore else */\n          if (MIDI_RESPONSE[response]) {\n            // It's ok that this.versionReceived will be set to\n            // true every time a valid MIDI_RESPONSE is received.\n            // This condition is necessary to ensure that REPORT_VERSION\n            // is called first.\n            if (this.versionReceived || first === REPORT_VERSION) {\n              this.versionReceived = true;\n              MIDI_RESPONSE[response](this);\n            }\n            this.currentBuffer.length = 0;\n          } else {\n            // A bad serial read must have happened.\n            // Reseting the buffer will allow recovery.\n            this.currentBuffer.length = 0;\n          }\n        }\n      }\n    }\n  }.bind(this));\n\n  // if we have not received the version within the alotted\n  // time specified by the reportVersionTimeout (user or default),\n  // then send an explicit request for it.\n  this.reportVersionTimeoutId = setTimeout(function() {\n    /* istanbul ignore else */\n    if (this.versionReceived === false) {\n      this.reportVersion(function() {});\n      this.queryFirmware(function() {});\n    }\n  }.bind(this), settings.reportVersionTimeout);\n\n  function ready() {\n    board.isReady = true;\n    board.emit(\"ready\");\n    /* istanbul ignore else */\n    if (typeof callback === \"function\") {\n      callback();\n    }\n  }\n\n  // Await the reported version.\n  this.once(\"reportversion\", function() {\n    clearTimeout(this.reportVersionTimeoutId);\n    this.versionReceived = true;\n    this.once(\"queryfirmware\", function() {\n\n      // Only preemptively set the sampling interval if `samplingInterval`\n      // property was _explicitly_ set as a constructor option.\n      if (options.samplingInterval !== undefined) {\n        this.setSamplingInterval(options.samplingInterval);\n      }\n      if (settings.skipCapabilities) {\n        this.analogPins = settings.analogPins || this.analogPins;\n        this.pins = settings.pins || this.pins;\n        /* istanbul ignore else */\n        if (!this.pins.length) {\n          for (var i = 0; i < (settings.pinCount || MAX_PIN_COUNT); i++) {\n            var analogChannel = this.analogPins.indexOf(i);\n            if (analogChannel < 0) {\n              analogChannel = 127;\n            }\n            this.pins.push({supportedModes: [], analogChannel: analogChannel});\n          }\n        }\n\n        // If the capabilities query is skipped,\n        // default resolution values will be used.\n        //\n        // Based on ATmega328/P\n        //\n        this.RESOLUTION.ADC = 0x3FF;\n        this.RESOLUTION.PWM = 0x0FF;\n\n        ready();\n      } else {\n        this.queryCapabilities(function() {\n          this.queryAnalogMapping(ready);\n        });\n      }\n    });\n  });\n}\n\nBoard.prototype = Object.create(Emitter.prototype, {\n  constructor: {\n    value: Board,\n  },\n});\n\n/**\n * writeToTransport Due to the non-blocking behaviour of transport write\n *                   operations, dependent programs need a way to know\n *                   when all writes are complete. Every write increments\n *                   a `pending` value, when the write operation has\n *                   completed, the `pending` value is decremented.\n *\n * @param  {Board} board An active Board instance\n * @param  {Array} data  An array of 8 and 7 bit values that will be\n *                       wrapped in a Buffer and written to the transport.\n */\nfunction writeToTransport(board, data) {\n  board.pending++;\n  board.transport.write(new Buffer(data), function() {\n    board.pending--;\n  });\n}\n\n/**\n * Asks the arduino to tell us its version.\n * @param {function} callback A function to be called when the arduino has reported its version.\n */\n\nBoard.prototype.reportVersion = function(callback) {\n  this.once(\"reportversion\", callback);\n  writeToTransport(this, [REPORT_VERSION]);\n};\n\n/**\n * Asks the arduino to tell us its firmware version.\n * @param {function} callback A function to be called when the arduino has reported its firmware version.\n */\n\nBoard.prototype.queryFirmware = function(callback) {\n  this.once(\"queryfirmware\", callback);\n  writeToTransport(this, [START_SYSEX, QUERY_FIRMWARE, END_SYSEX]);\n};\n\n/**\n * Asks the arduino to read analog data. Turn on reporting for this pin.\n * @param {number} pin The pin to read analog data\n * @param {function} callback A function to call when we have the analag data.\n */\n\nBoard.prototype.analogRead = function(pin, callback) {\n  this.reportAnalogPin(pin, 1);\n  this.addListener(\"analog-read-\" + pin, callback);\n};\n\n/**\n * Write a PWM value Asks the arduino to write an analog message.\n * @param {number} pin The pin to write analog data to.\n * @param {nubmer} value The data to write to the pin between 0 and this.RESOLUTION.PWM.\n */\n\nBoard.prototype.pwmWrite = function(pin, value) {\n  var data = [];\n\n  this.pins[pin].value = value;\n\n  if (pin > 15) {\n    data[0] = START_SYSEX;\n    data[1] = EXTENDED_ANALOG;\n    data[2] = pin;\n    data[3] = value & 0x7F;\n    data[4] = (value >> 7) & 0x7F;\n\n    if (value > 0x00004000) {\n      data[data.length] = (value >> 14) & 0x7F;\n    }\n\n    if (value > 0x00200000) {\n      data[data.length] = (value >> 21) & 0x7F;\n    }\n\n    if (value > 0x10000000) {\n      data[data.length] = (value >> 28) & 0x7F;\n    }\n\n    data[data.length] = END_SYSEX;\n  } else {\n    data.push(ANALOG_MESSAGE | pin, value & 0x7F, (value >> 7) & 0x7F);\n  }\n\n  writeToTransport(this, data);\n};\n\nBoard.prototype.analogWrite = Board.prototype.pwmWrite;\n\n/**\n * Set a pin to SERVO mode with an explicit PWM range.\n *\n * @param {number} pin The pin the servo is connected to\n * @param {number} min A 14-bit signed int.\n * @param {number} max A 14-bit signed int.\n */\n\nBoard.prototype.servoConfig = function(pin, min, max) {\n  var temp;\n\n  if (typeof pin === \"object\" && pin !== null) {\n    temp = pin;\n    pin = temp.pin;\n    min = temp.min;\n    max = temp.max;\n  }\n\n  if (typeof pin === \"undefined\") {\n    throw new Error(\"servoConfig: pin must be specified\");\n  }\n\n  if (typeof min === \"undefined\") {\n    throw new Error(\"servoConfig: min must be specified\");\n  }\n\n  if (typeof max === \"undefined\") {\n    throw new Error(\"servoConfig: max must be specified\");\n  }\n\n  // [0]  START_SYSEX  (0xF0)\n  // [1]  SERVO_CONFIG (0x70)\n  // [2]  pin number   (0-127)\n  // [3]  minPulse LSB (0-6)\n  // [4]  minPulse MSB (7-13)\n  // [5]  maxPulse LSB (0-6)\n  // [6]  maxPulse MSB (7-13)\n  // [7]  END_SYSEX    (0xF7)\n\n  this.pins[pin].mode = this.MODES.SERVO;\n\n  writeToTransport(this, [\n    START_SYSEX,\n    SERVO_CONFIG,\n    pin,\n    min & 0x7F,\n    (min >> 7) & 0x7F,\n    max & 0x7F,\n    (max >> 7) & 0x7F,\n    END_SYSEX,\n  ]);\n};\n\n/**\n * Asks the arduino to move a servo\n * @param {number} pin The pin the servo is connected to\n * @param {number} value The degrees to move the servo to.\n */\n\nBoard.prototype.servoWrite = function(pin, value) {\n  // Values less than 544 will be treated as angles in degrees\n  // (valid values in microseconds are handled as microseconds)\n  this.analogWrite.apply(this, arguments);\n};\n\n/**\n * Asks the arduino to set the pin to a certain mode.\n * @param {number} pin The pin you want to change the mode of.\n * @param {number} mode The mode you want to set. Must be one of board.MODES\n */\n\nBoard.prototype.pinMode = function(pin, mode) {\n  this.pins[pin].mode = mode;\n  writeToTransport(this, [PIN_MODE, pin, mode]);\n};\n\n/**\n * Asks the arduino to write a value to a digital pin\n * @param {number} pin The pin you want to write a value to.\n * @param {value} value The value you want to write. Must be board.HIGH or board.LOW\n */\n\nBoard.prototype.digitalWrite = function(pin, value) {\n  var port = pin >> 3;\n  var bit = 1 << (pin & 0x07);\n\n  this.pins[pin].value = value;\n\n  if (value) {\n    this.ports[port] |= bit;\n  } else {\n    this.ports[port] &= ~bit;\n  }\n\n  writeToTransport(this, [\n    DIGITAL_MESSAGE | port,\n    this.ports[port] & 0x7F,\n    (this.ports[port] >> 7) & 0x7F\n  ]);\n};\n\n/**\n * Asks the arduino to read digital data. Turn on reporting for this pin's port.\n *\n * @param {number} pin The pin to read data from\n * @param {function} callback The function to call when data has been received\n */\n\nBoard.prototype.digitalRead = function(pin, callback) {\n  this.reportDigitalPin(pin, 1);\n  this.addListener(\"digital-read-\" + pin, callback);\n};\n\n/**\n * Asks the arduino to tell us its capabilities\n * @param {function} callback A function to call when we receive the capabilities\n */\n\nBoard.prototype.queryCapabilities = function(callback) {\n  this.once(\"capability-query\", callback);\n  writeToTransport(this, [START_SYSEX, CAPABILITY_QUERY, END_SYSEX]);\n};\n\n/**\n * Asks the arduino to tell us its analog pin mapping\n * @param {function} callback A function to call when we receive the pin mappings.\n */\n\nBoard.prototype.queryAnalogMapping = function(callback) {\n  this.once(\"analog-mapping-query\", callback);\n  writeToTransport(this, [START_SYSEX, ANALOG_MAPPING_QUERY, END_SYSEX]);\n};\n\n/**\n * Asks the arduino to tell us the current state of a pin\n * @param {number} pin The pin we want to the know the state of\n * @param {function} callback A function to call when we receive the pin state.\n */\n\nBoard.prototype.queryPinState = function(pin, callback) {\n  this.once(\"pin-state-\" + pin, callback);\n  writeToTransport(this, [START_SYSEX, PIN_STATE_QUERY, pin, END_SYSEX]);\n};\n\n/**\n * Sends a string to the arduino\n * @param {String} string to send to the device\n */\n\nBoard.prototype.sendString = function(string) {\n  var bytes = new Buffer(string + \"\\0\", \"utf8\");\n  var data = [];\n  data.push(START_SYSEX);\n  data.push(STRING_DATA);\n  for (var i = 0, length = bytes.length; i < length; i++) {\n    data.push(bytes[i] & 0x7F);\n    data.push((bytes[i] >> 7) & 0x7F);\n  }\n  data.push(END_SYSEX);\n\n  writeToTransport(this, data);\n};\n\nfunction i2cRequest(board, bytes) {\n  var active = i2cActive.get(board);\n\n  if (!active) {\n    throw new Error(\"I2C is not enabled for this board. To enable, call the i2cConfig() method.\");\n  }\n\n  // Do not tamper with I2C_CONFIG messages\n  if (bytes[1] === I2C_REQUEST) {\n    var address = bytes[2];\n\n    // If no peripheral settings exist, make them.\n    if (!active[address]) {\n      active[address] = {\n        stopTX: true,\n      };\n    }\n\n    // READ (8) or CONTINUOUS_READ (16)\n    // value & 0b00011000\n    if (bytes[3] & I2C_READ_MASK) {\n      // Invert logic to accomodate default = true,\n      // which is actually stopTX = 0\n      bytes[3] |= Number(!active[address].stopTX) << 6;\n    }\n  }\n\n  writeToTransport(board, bytes);\n}\n\n/**\n * Sends a I2C config request to the arduino board with an optional\n * value in microseconds to delay an I2C Read.  Must be called before\n * an I2C Read or Write\n * @param {number} delay in microseconds to set for I2C Read\n */\n\nBoard.prototype.sendI2CConfig = function(delay) {\n  return this.i2cConfig(delay);\n};\n\n/**\n * Enable I2C with an optional read delay. Must be called before\n * an I2C Read or Write\n *\n * Supersedes sendI2CConfig\n *\n * @param {number} delay in microseconds to set for I2C Read\n *\n * or\n *\n * @param {object} with a single property `delay`\n */\n\nBoard.prototype.i2cConfig = function(options) {\n  var settings = i2cActive.get(this);\n  var delay;\n\n  if (!settings) {\n    settings = {\n      /*\n        Keys will be I2C peripheral addresses\n       */\n    };\n    i2cActive.set(this, settings);\n  }\n\n  if (typeof options === \"number\") {\n    delay = options;\n  } else {\n    if (typeof options === \"object\" && options !== null) {\n      delay = Number(options.delay);\n\n      // When an address was explicitly specified, there may also be\n      // peripheral specific instructions in the config.\n      if (typeof options.address !== \"undefined\") {\n        if (!settings[options.address]) {\n          settings[options.address] = {\n            stopTX: true,\n          };\n        }\n      }\n\n      // When settings have been explicitly provided, just bulk assign\n      // them to the existing settings, even if that's empty. This\n      // allows for reconfiguration as needed.\n      if (typeof options.settings !== \"undefined\") {\n        Object.assign(settings[options.address], options.settings);\n        /*\n          - stopTX: true | false\n              Set `stopTX` to `false` if this peripheral\n              expects Wire to keep the transmission connection alive between\n              setting a register and requesting bytes.\n\n              Defaults to `true`.\n         */\n      }\n    }\n  }\n\n  settings.delay = delay = delay || 0;\n\n  i2cRequest(this, [\n    START_SYSEX,\n    I2C_CONFIG,\n    delay & 0xFF, (delay >> 8) & 0xFF,\n    END_SYSEX,\n  ]);\n\n  return this;\n};\n\n/**\n * Asks the arduino to send an I2C request to a device\n * @param {number} slaveAddress The address of the I2C device\n * @param {Array} bytes The bytes to send to the device\n */\n\nBoard.prototype.sendI2CWriteRequest = function(slaveAddress, bytes) {\n  var data = [];\n  /* istanbul ignore next */\n  bytes = bytes || [];\n\n  data.push(\n    START_SYSEX,\n    I2C_REQUEST,\n    slaveAddress,\n    this.I2C_MODES.WRITE << 3\n  );\n\n  for (var i = 0, length = bytes.length; i < length; i++) {\n    data.push(\n      bytes[i] & 0x7F, (bytes[i] >> 7) & 0x7F\n    );\n  }\n\n  data.push(END_SYSEX);\n\n  i2cRequest(this, data);\n};\n\n/**\n * Write data to a register\n *\n * @param {number} address      The address of the I2C device.\n * @param {array} cmdRegOrData  An array of bytes\n *\n * Write a command to a register\n *\n * @param {number} address      The address of the I2C device.\n * @param {number} cmdRegOrData The register\n * @param {array} inBytes       An array of bytes\n *\n */\n\nBoard.prototype.i2cWrite = function(address, registerOrData, inBytes) {\n  /**\n   * registerOrData:\n   * [... arbitrary bytes]\n   *\n   * or\n   *\n   * registerOrData, inBytes:\n   * command [, ...]\n   *\n   */\n  var bytes;\n  var data = [\n    START_SYSEX,\n    I2C_REQUEST,\n    address,\n    this.I2C_MODES.WRITE << 3\n  ];\n\n  // If i2cWrite was used for an i2cWriteReg call...\n  if (arguments.length === 3 &&\n      !Array.isArray(registerOrData) &&\n      !Array.isArray(inBytes)) {\n\n    return this.i2cWriteReg(address, registerOrData, inBytes);\n  }\n\n  // Fix arguments if called with Firmata.js API\n  if (arguments.length === 2) {\n    if (Array.isArray(registerOrData)) {\n      inBytes = registerOrData.slice();\n      registerOrData = inBytes.shift();\n    } else {\n      inBytes = [];\n    }\n  }\n\n  bytes = new Buffer([registerOrData].concat(inBytes));\n\n  for (var i = 0, length = bytes.length; i < length; i++) {\n    data.push(\n      bytes[i] & 0x7F, (bytes[i] >> 7) & 0x7F\n    );\n  }\n\n  data.push(END_SYSEX);\n\n  i2cRequest(this, data);\n\n  return this;\n};\n\n/**\n * Write data to a register\n *\n * @param {number} address    The address of the I2C device.\n * @param {number} register   The register.\n * @param {number} byte       The byte value to write.\n *\n */\n\nBoard.prototype.i2cWriteReg = function(address, register, byte) {\n  i2cRequest(this, [\n    START_SYSEX,\n    I2C_REQUEST,\n    address,\n    this.I2C_MODES.WRITE << 3,\n    // register\n    register & 0x7F, (register >> 7) & 0x7F,\n    // byte\n    byte & 0x7F, (byte >> 7) & 0x7F,\n    END_SYSEX,\n  ]);\n\n  return this;\n};\n\n\n/**\n * Asks the arduino to request bytes from an I2C device\n * @param {number} slaveAddress The address of the I2C device\n * @param {number} numBytes The number of bytes to receive.\n * @param {function} callback A function to call when we have received the bytes.\n */\n\nBoard.prototype.sendI2CReadRequest = function(address, numBytes, callback) {\n  i2cRequest(this, [\n    START_SYSEX,\n    I2C_REQUEST,\n    address,\n    this.I2C_MODES.READ << 3,\n    numBytes & 0x7F, (numBytes >> 7) & 0x7F,\n    END_SYSEX,\n  ]);\n  this.once(\"I2C-reply-\" + address + \"-0\" , callback);\n};\n\n// TODO: Refactor i2cRead and i2cReadOnce\n//      to share most operations.\n\n/**\n * Initialize a continuous I2C read.\n *\n * @param {number} address    The address of the I2C device\n * @param {number} register   Optionally set the register to read from.\n * @param {number} numBytes   The number of bytes to receive.\n * @param {function} callback A function to call when we have received the bytes.\n */\n\nBoard.prototype.i2cRead = function(address, register, bytesToRead, callback) {\n\n  if (arguments.length === 3 &&\n      typeof register === \"number\" &&\n      typeof bytesToRead === \"function\") {\n    callback = bytesToRead;\n    bytesToRead = register;\n    register = null;\n  }\n\n  var event = \"I2C-reply-\" + address + \"-\";\n  var data = [\n    START_SYSEX,\n    I2C_REQUEST,\n    address,\n    this.I2C_MODES.CONTINUOUS_READ << 3,\n  ];\n\n  if (register !== null) {\n    data.push(\n      register & 0x7F, (register >> 7) & 0x7F\n    );\n  } else {\n    register = 0;\n  }\n\n  event += register;\n\n  data.push(\n    bytesToRead & 0x7F, (bytesToRead >> 7) & 0x7F,\n    END_SYSEX\n  );\n\n  this.on(event, callback);\n\n  i2cRequest(this, data);\n\n  return this;\n};\n\n/**\n * Stop continuous reading of the specified I2C address or register.\n *\n * @param {object} options Options:\n *   bus {number} The I2C bus (on supported platforms)\n *   address {number} The I2C peripheral address to stop reading.\n *\n * @param {number} address The I2C peripheral address to stop reading.\n */\n\nBoard.prototype.i2cStop = function(options) {\n  // There may be more values in the future\n  // var options = {};\n\n  // null or undefined? Do nothing.\n  if (options == null) {\n    return;\n  }\n\n  if (typeof options === \"number\") {\n    options = {\n      address: options\n    };\n  }\n\n  writeToTransport(this, [\n    START_SYSEX,\n    I2C_REQUEST,\n    options.address,\n    this.I2C_MODES.STOP_READING << 3,\n    END_SYSEX,\n  ]);\n\n  Object.keys(this._events).forEach(function(event) {\n    if (event.startsWith(\"I2C-reply-\" + options.address)) {\n      this.removeAllListeners(event);\n    }\n  }, this);\n};\n\n\n/**\n * Perform a single I2C read\n *\n * Supersedes sendI2CReadRequest\n *\n * Read bytes from address\n *\n * @param {number} address    The address of the I2C device\n * @param {number} register   Optionally set the register to read from.\n * @param {number} numBytes   The number of bytes to receive.\n * @param {function} callback A function to call when we have received the bytes.\n *\n */\n\n\nBoard.prototype.i2cReadOnce = function(address, register, bytesToRead, callback) {\n\n  if (arguments.length === 3 &&\n      typeof register === \"number\" &&\n      typeof bytesToRead === \"function\") {\n    callback = bytesToRead;\n    bytesToRead = register;\n    register = null;\n  }\n\n  var event = \"I2C-reply-\" + address + \"-\";\n  var data = [\n    START_SYSEX,\n    I2C_REQUEST,\n    address,\n    this.I2C_MODES.READ << 3,\n  ];\n\n  if (register !== null) {\n    data.push(\n      register & 0x7F, (register >> 7) & 0x7F\n    );\n  } else {\n    register = 0;\n  }\n\n  event += register;\n\n  data.push(\n    bytesToRead & 0x7F, (bytesToRead >> 7) & 0x7F,\n    END_SYSEX\n  );\n\n  this.once(event, callback);\n\n  i2cRequest(this, data);\n\n  return this;\n};\n\n// CONTINUOUS_READ\n\n/**\n * Configure the passed pin as the controller in a 1-wire bus.\n * Pass as enableParasiticPower true if you want the data pin to power the bus.\n * @param pin\n * @param enableParasiticPower\n */\n\nBoard.prototype.sendOneWireConfig = function(pin, enableParasiticPower) {\n  writeToTransport(this, [\n    START_SYSEX,\n    ONEWIRE_DATA,\n    ONEWIRE_CONFIG_REQUEST,\n    pin,\n    enableParasiticPower ? 0x01 : 0x00,\n    END_SYSEX\n  ]);\n};\n\n/**\n * Searches for 1-wire devices on the bus.  The passed callback should accept\n * and error argument and an array of device identifiers.\n * @param pin\n * @param callback\n */\n\nBoard.prototype.sendOneWireSearch = function(pin, callback) {\n  this._sendOneWireSearch(ONEWIRE_SEARCH_REQUEST, \"1-wire-search-reply-\" + pin, pin, callback);\n};\n\n/**\n * Searches for 1-wire devices on the bus in an alarmed state.  The passed callback\n * should accept and error argument and an array of device identifiers.\n * @param pin\n * @param callback\n */\n\nBoard.prototype.sendOneWireAlarmsSearch = function(pin, callback) {\n  this._sendOneWireSearch(ONEWIRE_SEARCH_ALARMS_REQUEST, \"1-wire-search-alarms-reply-\" + pin, pin, callback);\n};\n\nBoard.prototype._sendOneWireSearch = function(type, event, pin, callback) {\n  writeToTransport(this, [START_SYSEX, ONEWIRE_DATA, type, pin, END_SYSEX]);\n\n  var searchTimeout = setTimeout(function() {\n    /* istanbul ignore next */\n    callback(new Error(\"1-Wire device search timeout - are you running ConfigurableFirmata?\"));\n  }, 5000);\n  this.once(event, function(devices) {\n    clearTimeout(searchTimeout);\n    callback(null, devices);\n  });\n};\n\n/**\n * Reads data from a device on the bus and invokes the passed callback.\n *\n * N.b. ConfigurableFirmata will issue the 1-wire select command internally.\n * @param pin\n * @param device\n * @param numBytesToRead\n * @param callback\n */\n\nBoard.prototype.sendOneWireRead = function(pin, device, numBytesToRead, callback) {\n  var correlationId = Math.floor(Math.random() * 255);\n  /* istanbul ignore next */\n  var readTimeout = setTimeout(function() {\n    /* istanbul ignore next */\n    callback(new Error(\"1-Wire device read timeout - are you running ConfigurableFirmata?\"));\n  }, 5000);\n  this._sendOneWireRequest(pin, ONEWIRE_READ_REQUEST_BIT, device, numBytesToRead, correlationId, null, null, \"1-wire-read-reply-\" + correlationId, function(data) {\n    clearTimeout(readTimeout);\n    callback(null, data);\n  });\n};\n\n/**\n * Resets all devices on the bus.\n * @param pin\n */\n\nBoard.prototype.sendOneWireReset = function(pin) {\n  this._sendOneWireRequest(pin, ONEWIRE_RESET_REQUEST_BIT);\n};\n\n/**\n * Writes data to the bus to be received by the passed device.  The device\n * should be obtained from a previous call to sendOneWireSearch.\n *\n * N.b. ConfigurableFirmata will issue the 1-wire select command internally.\n * @param pin\n * @param device\n * @param data\n */\n\nBoard.prototype.sendOneWireWrite = function(pin, device, data) {\n  this._sendOneWireRequest(pin, ONEWIRE_WRITE_REQUEST_BIT, device, null, null, null, Array.isArray(data) ? data : [data]);\n};\n\n/**\n * Tells firmata to not do anything for the passed amount of ms.  For when you\n * need to give a device attached to the bus time to do a calculation.\n * @param pin\n */\n\nBoard.prototype.sendOneWireDelay = function(pin, delay) {\n  this._sendOneWireRequest(pin, ONEWIRE_DELAY_REQUEST_BIT, null, null, null, delay);\n};\n\n/**\n * Sends the passed data to the passed device on the bus, reads the specified\n * number of bytes and invokes the passed callback.\n *\n * N.b. ConfigurableFirmata will issue the 1-wire select command internally.\n * @param pin\n * @param device\n * @param data\n * @param numBytesToRead\n * @param callback\n */\n\nBoard.prototype.sendOneWireWriteAndRead = function(pin, device, data, numBytesToRead, callback) {\n  var correlationId = Math.floor(Math.random() * 255);\n  /* istanbul ignore next */\n  var readTimeout = setTimeout(function() {\n    /* istanbul ignore next */\n    callback(new Error(\"1-Wire device read timeout - are you running ConfigurableFirmata?\"));\n  }, 5000);\n  this._sendOneWireRequest(pin, ONEWIRE_WRITE_REQUEST_BIT | ONEWIRE_READ_REQUEST_BIT, device, numBytesToRead, correlationId, null, Array.isArray(data) ? data : [data], \"1-wire-read-reply-\" + correlationId, function(data) {\n    clearTimeout(readTimeout);\n\n    callback(null, data);\n  });\n};\n\n// see http://firmata.org/wiki/Proposals#OneWire_Proposal\nBoard.prototype._sendOneWireRequest = function(pin, subcommand, device, numBytesToRead, correlationId, delay, dataToWrite, event, callback) {\n  var bytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n  if (device || numBytesToRead || correlationId || delay || dataToWrite) {\n    subcommand = subcommand | ONEWIRE_WITHDATA_REQUEST_BITS;\n  }\n\n  if (device) {\n    bytes.splice.apply(bytes, [0, 8].concat(device));\n  }\n\n  if (numBytesToRead) {\n    bytes[8] = numBytesToRead & 0xFF;\n    bytes[9] = (numBytesToRead >> 8) & 0xFF;\n  }\n\n  if (correlationId) {\n    bytes[10] = correlationId & 0xFF;\n    bytes[11] = (correlationId >> 8) & 0xFF;\n  }\n\n  if (delay) {\n    bytes[12] = delay & 0xFF;\n    bytes[13] = (delay >> 8) & 0xFF;\n    bytes[14] = (delay >> 16) & 0xFF;\n    bytes[15] = (delay >> 24) & 0xFF;\n  }\n\n  if (dataToWrite) {\n    dataToWrite.forEach(function(byte) {\n      bytes.push(byte);\n    });\n  }\n\n  var output = [START_SYSEX, ONEWIRE_DATA, subcommand, pin];\n  output = output.concat(Encoder7Bit.to7BitArray(bytes));\n  output.push(END_SYSEX);\n\n  writeToTransport(this, output);\n\n  if (event && callback) {\n    this.once(event, callback);\n  }\n};\n\n/**\n * Set sampling interval in millis. Default is 19 ms\n * @param {number} interval The sampling interval in ms > 10\n */\n\nBoard.prototype.setSamplingInterval = function(interval) {\n  var safeint = interval < 10 ? 10 : (interval > 65535 ? 65535 : interval);\n  this.settings.samplingInterval = safeint;\n  writeToTransport(this, [\n    START_SYSEX,\n    SAMPLING_INTERVAL,\n    (safeint & 0x7F),\n    ((safeint >> 7) & 0x7F),\n    END_SYSEX\n  ]);\n};\n\n/**\n * Get sampling interval in millis. Default is 19 ms\n *\n * @return {number} samplingInterval\n */\n\nBoard.prototype.getSamplingInterval = function() {\n  return this.settings.samplingInterval;\n};\n\n/**\n * Set reporting on pin\n * @param {number} pin The pin to turn on/off reporting\n * @param {number} value Binary value to turn reporting on/off\n */\n\nBoard.prototype.reportAnalogPin = function(pin, value) {\n  /* istanbul ignore else */\n  if (value === 0 || value === 1) {\n    this.pins[this.analogPins[pin]].report = value;\n    writeToTransport(this, [REPORT_ANALOG | pin, value]);\n  }\n};\n\n/**\n * Set reporting on pin\n * @param {number} pin The pin to turn on/off reporting\n * @param {number} value Binary value to turn reporting on/off\n */\n\nBoard.prototype.reportDigitalPin = function(pin, value) {\n  var port = pin >> 3;\n  /* istanbul ignore else */\n  if (value === 0 || value === 1) {\n    this.pins[pin].report = value;\n    writeToTransport(this, [REPORT_DIGITAL | port, value]);\n  }\n};\n\n/**\n *\n *\n */\n\nBoard.prototype.pingRead = function(opts, callback) {\n\n  if (this.pins[opts.pin].supportedModes.indexOf(PING_READ) === -1) {\n    throw new Error(\"Please upload PingFirmata to the board\");\n  }\n\n  var pin = opts.pin;\n  var value = opts.value;\n  var pulseOut = opts.pulseOut || 0;\n  var timeout = opts.timeout || 1000000;\n  var pulseOutArray = [\n    (pulseOut >> 24) & 0xFF,\n    (pulseOut >> 16) & 0xFF,\n    (pulseOut >> 8) & 0XFF,\n    (pulseOut & 0xFF),\n  ];\n  var timeoutArray = [\n    (timeout >> 24) & 0xFF,\n    (timeout >> 16) & 0xFF,\n    (timeout >> 8) & 0XFF,\n    (timeout & 0xFF),\n  ];\n\n  writeToTransport(this, [\n    START_SYSEX,\n    PING_READ,\n    pin,\n    value,\n    pulseOutArray[0] & 0x7F, (pulseOutArray[0] >> 7) & 0x7F,\n    pulseOutArray[1] & 0x7F, (pulseOutArray[1] >> 7) & 0x7F,\n    pulseOutArray[2] & 0x7F, (pulseOutArray[2] >> 7) & 0x7F,\n    pulseOutArray[3] & 0x7F, (pulseOutArray[3] >> 7) & 0x7F,\n    timeoutArray[0] & 0x7F, (timeoutArray[0] >> 7) & 0x7F,\n    timeoutArray[1] & 0x7F, (timeoutArray[1] >> 7) & 0x7F,\n    timeoutArray[2] & 0x7F, (timeoutArray[2] >> 7) & 0x7F,\n    timeoutArray[3] & 0x7F, (timeoutArray[3] >> 7) & 0x7F,\n    END_SYSEX,\n  ]);\n\n  this.once(\"ping-read-\" + pin, callback);\n};\n\n/**\n * Stepper functions to support AdvancedFirmata\"s asynchronous control of stepper motors\n * https://github.com/soundanalogous/AdvancedFirmata\n */\n\n/**\n * Asks the arduino to configure a stepper motor with the given config to allow asynchronous control of the stepper\n * @param {number} deviceNum Device number for the stepper (range 0-5, expects steppers to be setup in order from 0 to 5)\n * @param {number} type One of this.STEPPER.TYPE.*\n * @param {number} stepsPerRev Number of steps motor takes to make one revolution\n * @param {number} dirOrMotor1Pin If using EasyDriver type stepper driver, this is direction pin, otherwise it is motor 1 pin\n * @param {number} stepOrMotor2Pin If using EasyDriver type stepper driver, this is step pin, otherwise it is motor 2 pin\n * @param {number} [motor3Pin] Only required if type == this.STEPPER.TYPE.FOUR_WIRE\n * @param {number} [motor4Pin] Only required if type == this.STEPPER.TYPE.FOUR_WIRE\n */\n\nBoard.prototype.stepperConfig = function(deviceNum, type, stepsPerRev, dirOrMotor1Pin, stepOrMotor2Pin, motor3Pin, motor4Pin) {\n  var data = [\n    START_SYSEX,\n    STEPPER,\n    0x00, // STEPPER_CONFIG from firmware\n    deviceNum,\n    type,\n    stepsPerRev & 0x7F, (stepsPerRev >> 7) & 0x7F,\n    dirOrMotor1Pin,\n    stepOrMotor2Pin,\n  ];\n  if (type === this.STEPPER.TYPE.FOUR_WIRE) {\n    data.push(motor3Pin, motor4Pin);\n  }\n  data.push(END_SYSEX);\n  writeToTransport(this, data);\n};\n\n/**\n * Asks the arduino to move a stepper a number of steps at a specific speed\n * (and optionally with and acceleration and deceleration)\n * speed is in units of .01 rad/sec\n * accel and decel are in units of .01 rad/sec^2\n * TODO: verify the units of speed, accel, and decel\n * @param {number} deviceNum Device number for the stepper (range 0-5)\n * @param {number} direction One of this.STEPPER.DIRECTION.*\n * @param {number} steps Number of steps to make\n * @param {number} speed\n * @param {number|function} accel Acceleration or if accel and decel are not used, then it can be the callback\n * @param {number} [decel]\n * @param {function} [callback]\n */\n\nBoard.prototype.stepperStep = function(deviceNum, direction, steps, speed, accel, decel, callback) {\n  if (typeof accel === \"function\") {\n    callback = accel;\n    accel = 0;\n    decel = 0;\n  }\n\n  var data = [\n    START_SYSEX,\n    STEPPER,\n    0x01, // STEPPER_STEP from firmware\n    deviceNum,\n    direction, // one of this.STEPPER.DIRECTION.*\n    steps & 0x7F, (steps >> 7) & 0x7F, (steps >> 14) & 0x7f,\n    speed & 0x7F, (speed >> 7) & 0x7F\n  ];\n  if (accel > 0 || decel > 0) {\n    data.push(\n      accel & 0x7F, (accel >> 7) & 0x7F,\n      decel & 0x7F, (decel >> 7) & 0x7F\n    );\n  }\n  data.push(END_SYSEX);\n  writeToTransport(this, data);\n  this.once(\"stepper-done-\" + deviceNum, callback);\n};\n\n/**\n * Asks the Arduino to configure a hardware or serial port.\n * @param {object} options Options:\n *   portId {number} The serial port to use (HW_SERIAL1, HW_SERIAL2, HW_SERIAL3, SW_SERIAL0,\n *   SW_SERIAL1, SW_SERIAL2, SW_SERIAL3)\n *   baud {number} The baud rate of the serial port\n *   rxPin {number} [SW Serial only] The RX pin of the SoftwareSerial instance\n *   txPin {number} [SW Serial only] The TX pin of the SoftwareSerial instance\n */\n\nBoard.prototype.serialConfig = function(options) {\n\n  var portId;\n  var baud;\n  var rxPin;\n  var txPin;\n\n  /* istanbul ignore else */\n  if (typeof options === \"object\" && options !== null) {\n    portId = options.portId;\n    baud = options.baud;\n    rxPin = options.rxPin;\n    txPin = options.txPin;\n  }\n\n  /* istanbul ignore else */\n  if (typeof portId === \"undefined\") {\n    throw new Error(\"portId must be specified, see SERIAL_PORT_IDs for options.\");\n  }\n\n  baud = baud || 57600;\n\n  var data = [\n    START_SYSEX,\n    SERIAL_MESSAGE,\n    SERIAL_CONFIG | portId,\n    baud & 0x007F,\n    (baud >> 7) & 0x007F,\n    (baud >> 14) & 0x007F\n  ];\n  if (portId > 7 && typeof rxPin !== \"undefined\" && typeof txPin !== \"undefined\") {\n    data.push(rxPin);\n    data.push(txPin);\n  } else if (portId > 7) {\n    throw new Error(\"Both RX and TX pins must be defined when using Software Serial.\");\n  }\n\n  data.push(END_SYSEX);\n  writeToTransport(this, data);\n};\n\n/**\n * Write an array of bytes to the specified serial port.\n * @param {number} portId The serial port to write to.\n * @param {array} inBytes An array of bytes to write to the serial port.\n */\n\nBoard.prototype.serialWrite = function(portId, inBytes) {\n  var data = [\n    START_SYSEX,\n    SERIAL_MESSAGE,\n    SERIAL_WRITE | portId,\n  ];\n  for (var i = 0, len = inBytes.length; i < len; i++) {\n    data.push(inBytes[i] & 0x007F);\n    data.push((inBytes[i] >> 7) & 0x007F);\n  }\n  data.push(END_SYSEX);\n  /* istanbul ignore else */\n  if (inBytes.length > 0) {\n    writeToTransport(this, data);\n  }\n};\n\n/**\n * Start continuous reading of the specified serial port. The port is checked for data each\n * iteration of the main Arduino loop.\n * @param {number} portId The serial port to start reading continuously.\n * @param {number} maxBytesToRead [Optional] The maximum number of bytes to read per iteration.\n * If there are less bytes in the buffer, the lesser number of bytes will be returned. A value of 0\n * indicates that all available bytes in the buffer should be read.\n * @param {function} callback A function to call when we have received the bytes.\n */\n\nBoard.prototype.serialRead = function(portId, maxBytesToRead, callback) {\n  var data = [\n    START_SYSEX,\n    SERIAL_MESSAGE,\n    SERIAL_READ | portId,\n    this.SERIAL_MODES.CONTINUOUS_READ\n  ];\n\n  if (arguments.length === 2 && typeof maxBytesToRead === \"function\") {\n    callback = maxBytesToRead;\n  } else {\n    data.push(maxBytesToRead & 0x007F);\n    data.push((maxBytesToRead >> 7) & 0x007F);\n  }\n\n  data.push(END_SYSEX);\n  writeToTransport(this, data);\n\n  this.on(\"serial-data-\" + portId, callback);\n};\n\n/**\n * Stop continuous reading of the specified serial port. This does not close the port, it stops\n * reading it but keeps the port open.\n * @param {number} portId The serial port to stop reading.\n */\n\nBoard.prototype.serialStop = function(portId) {\n  writeToTransport(this, [\n    START_SYSEX,\n    SERIAL_MESSAGE,\n    SERIAL_READ | portId,\n    this.SERIAL_MODES.STOP_READING,\n    END_SYSEX,\n  ]);\n\n  this.removeAllListeners(\"serial-data-\" + portId);\n};\n\n/**\n * Close the specified serial port.\n * @param {number} portId The serial port to close.\n */\n\nBoard.prototype.serialClose = function(portId) {\n  writeToTransport(this, [\n    START_SYSEX,\n    SERIAL_MESSAGE,\n    SERIAL_CLOSE | portId,\n    END_SYSEX,\n  ]);\n};\n\n/**\n * Flush the specified serial port. For hardware serial, this waits for the transmission of\n * outgoing serial data to complete. For software serial, this removed any buffered incoming serial\n * data.\n * @param {number} portId The serial port to flush.\n */\n\nBoard.prototype.serialFlush = function(portId) {\n  writeToTransport(this, [\n    START_SYSEX,\n    SERIAL_MESSAGE,\n    SERIAL_FLUSH | portId,\n    END_SYSEX,\n  ]);\n};\n\n/**\n * For SoftwareSerial only. Only a single SoftwareSerial instance can read data at a time.\n * Call this method to set this port to be the reading port in the case there are multiple\n * SoftwareSerial instances.\n * @param {number} portId The serial port to listen on.\n */\n\nBoard.prototype.serialListen = function(portId) {\n  // listen only applies to software serial ports\n  if (portId < 8) {\n    return;\n  }\n  writeToTransport(this, [\n    START_SYSEX,\n    SERIAL_MESSAGE,\n    SERIAL_LISTEN | portId,\n    END_SYSEX,\n  ]);\n};\n\n/**\n * Allow user code to handle arbitrary sysex responses\n *\n * @param {number} commandByte The commandByte must be associated with some message\n *                             that's expected from the slave device. The handler is\n *                             called with an array of _raw_ data from the slave. Data\n *                             decoding must be done within the handler itself.\n *\n *                             Use Board.decode(data) to extract useful values from\n *                             the incoming response data.\n *\n *  @param {function} handler Function which handles receipt of responses matching\n *                            commandByte.\n */\n\nBoard.prototype.sysexResponse = function(commandByte, handler) {\n  if (Board.SYSEX_RESPONSE[commandByte]) {\n    throw new Error(commandByte + \" is not an available SYSEX_RESPONSE byte\");\n  }\n\n  Board.SYSEX_RESPONSE[commandByte] = function(board) {\n    handler(board.currentBuffer.slice(2, -1));\n  };\n\n  return this;\n};\n\n/**\n * Allow user code to send arbitrary sysex messages\n *\n * @param {array} message The message array is expected to be all necessary bytes\n *                        between START_SYSEX and END_SYSEX (non-inclusive). It will\n *                        be assumed that the data in the message array is\n *                        already encoded as 2 7-bit bytes LSB first.\n *\n *\n */\n\nBoard.prototype.sysexCommand = function(message) {\n\n  if (!message || !message.length) {\n    throw new Error(\"Sysex Command cannot be empty\");\n  }\n\n  var data = message.slice();\n\n  data.unshift(START_SYSEX);\n  data.push(END_SYSEX);\n\n  writeToTransport(this, data);\n  return this;\n};\n\n\n/**\n * Send SYSTEM_RESET to arduino\n */\n\nBoard.prototype.reset = function() {\n  writeToTransport(this, [SYSTEM_RESET]);\n};\n\n/**\n * Board.isAcceptablePort Determines if a `port` object (from SerialPort.list(...))\n * is a valid Arduino (or similar) device.\n * @return {Boolean} true if port can be connected to by Firmata\n */\n\nBoard.isAcceptablePort = function(port) {\n  var rport = /usb|acm|^com/i;\n\n  if (rport.test(port.comName)) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Board.requestPort(callback) Request an acceptable port to connect to.\n * callback(error, port)\n */\n\nBoard.requestPort = function(callback) {\n  com.list(function(error, ports) {\n    var port = ports.find(function(port) {\n      if (Board.isAcceptablePort(port)) {\n        return port;\n      }\n    });\n\n    if (port) {\n      callback(null, port);\n    } else {\n      callback(new Error(\"No Acceptable Port Found\"), null);\n    }\n  });\n};\n\n// For backwards compatibility\nBoard.Board = Board;\nBoard.SYSEX_RESPONSE = SYSEX_RESPONSE;\nBoard.MIDI_RESPONSE = MIDI_RESPONSE;\n\n// Expose encode/decode for custom sysex messages\nBoard.encode = function(data) {\n  var encoded = [];\n  var length = data.length;\n\n  for (var i = 0; i < length; i++) {\n    encoded.push(\n      data[i] & 0x7F,\n      (data[i] >> 7) & 0x7F\n    );\n  }\n\n  return encoded;\n};\n\nBoard.decode = function(data) {\n  var decoded = [];\n\n  if (data.length % 2 !== 0) {\n    throw new Error(\"Board.decode(data) called with odd number of data bytes\");\n  }\n\n  while (data.length) {\n    var lsb = data.shift();\n    var msb = data.shift();\n    decoded.push(lsb | (msb << 7));\n  }\n\n  return decoded;\n};\n\n/* istanbul ignore else */\nif (process.env.IS_TEST_MODE) {\n  Board.test = {\n    writeToTransport: writeToTransport,\n    i2cPeripheralSettings: function(board) {\n      return i2cActive.get(board);\n    },\n    get i2cActive() {\n      return i2cActive;\n    }\n  };\n}\n\nmodule.exports = Board;\n","/home/travis/build/npmtest/node-npmtest-firmata/node_modules/firmata/lib/encoder7bit.js":"/**\n * \"Inspired\" by Encoder7Bit.h/Encoder7Bit.cpp in the\n * Firmata source code.\n */\nmodule.exports = {\n  to7BitArray: function(data) {\n    var shift = 0;\n    var previous = 0;\n    var output = [];\n\n    data.forEach(function(byte) {\n      if (shift === 0) {\n        output.push(byte & 0x7f);\n        shift++;\n        previous = byte >> 7;\n      } else {\n        output.push(((byte << shift) & 0x7f) | previous);\n        if (shift === 6) {\n          output.push(byte >> 1);\n          shift = 0;\n        } else {\n          shift++;\n          previous = byte >> (8 - shift);\n        }\n      }\n    });\n\n    if (shift > 0) {\n      output.push(previous);\n    }\n\n    return output;\n  },\n  from7BitArray: function(encoded) {\n    var expectedBytes = (encoded.length) * 7 >> 3;\n    var decoded = [];\n\n    for (var i = 0; i < expectedBytes; i++) {\n      var j = i << 3;\n      var pos = parseInt(j / 7, 10);\n      var shift = j % 7;\n      decoded[i] = (encoded[pos] >> shift) | ((encoded[pos + 1] << (7 - shift)) & 0xFF);\n    }\n\n    return decoded;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-firmata/node_modules/firmata/lib/onewireutils.js":"var Encoder7Bit = require(\"./encoder7bit\");\n\nvar OneWireUtils = {\n  crc8: function(data) {\n    var crc = 0;\n\n    for (var i = 0; i < data.length; i++) {\n      var inbyte = data[i];\n\n      for (var n = 8; n; n--) {\n        var mix = (crc ^ inbyte) & 0x01;\n        crc >>= 1;\n\n        if (mix) {\n          crc ^= 0x8C;\n        }\n\n        inbyte >>= 1;\n      }\n    }\n    return crc;\n  },\n\n  readDevices: function(data) {\n    var deviceBytes = Encoder7Bit.from7BitArray(data);\n    var devices = [];\n\n    for (var i = 0; i < deviceBytes.length; i += 8) {\n      var device = deviceBytes.slice(i, i + 8);\n\n      if (device.length !== 8) {\n        continue;\n      }\n\n      var check = OneWireUtils.crc8(device.slice(0, 7));\n\n      if (check !== device[7]) {\n        console.error(\"ROM invalid!\");\n      }\n\n      devices.push(device);\n    }\n\n    return devices;\n  }\n};\n\nmodule.exports = OneWireUtils;\n","/home/travis/build/npmtest/node-npmtest-firmata/node_modules/firmata/lib/com.js":"var Emitter = require(\"events\").EventEmitter;\n\nfunction Mock(path) {\n  this.isClosed = false;\n}\n\nMock.prototype = Object.create(Emitter.prototype, {\n  constructor: {\n    value: Mock\n  }\n});\n\nMock.prototype.write = function (buffer) {\n  // Tests are written to work with arrays not buffers\n  // this shouldn\"t impact the data, just the container\n  // This also should be changed in future test rewrites\n  if (Buffer.isBuffer(buffer)) {\n    buffer = Array.prototype.slice.call(buffer, 0);\n  }\n\n  this.lastWrite = buffer;\n  this.emit(\"write\", buffer);\n};\n\n/* istanbul ignore next */\nMock.prototype.close = function () {\n  this.isClosed = true;\n};\n\nvar com;\nvar sp;\nvar stub = {\n  SerialPort: Mock,\n  list: function() {},\n};\n\ntry {\n  /* istanbul ignore if */\n  if (process.browser || parseFloat(process.versions.nw) >= 0.13) {\n    com = require(\"browser-serialport\");\n  } else {\n    /* istanbul ignore else */\n    if (process.env.IS_TEST_MODE) {\n      com = stub;\n    } else {\n      sp = require(\"serialport\");\n      com = {\n        SerialPort: sp,\n        list: sp.list,\n      };\n    }\n  }\n} catch (err) {}\n\n\n/* istanbul ignore if */\nif (com == null) {\n  if (process.env.IS_TEST_MODE) {\n    com = stub;\n  } else {\n    console.log(\"It looks like serialport didn't compile properly. This is a common problem and its fix is well documented here https://github.com/voodootikigod/node-serialport#to-install\");\n    console.log(\"The result of requiring the package is: \", sp);\n    throw \"Missing serialport dependency\";\n  }\n}\n\nmodule.exports = com;\n","/home/travis/build/npmtest/node-npmtest-firmata/node_modules/firmata/repl.js":"#!/usr/bin/env node\n\nvar firmata = require('./lib/firmata.js'),\n    repl = require('repl');\nconsole.log('Enter USB Port and press enter:');\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.once('data', function(chunk) {\n    var port = chunk.replace('\\n', '');\n    var board = new firmata.Board(port, function() {\n        console.log('Successfully Connected to ' + port);\n        repl.start('firmata>').context.board = board;\n    });\n});"}